# Evidencias de la unidad 8

### Actividad 01

1. Conexiones sonido - imagen de las performances
    
    * **Sonar+D (Carles Viarnès & Alba G. Corral)**
    
      > En esta obra, la música de piano y ambient se mezclan con unas visuales envolventes que parecen respiran al ritmo de la música. Veo que habian formas que se expanden lentamente con sonidos graves y se algunas se iluminan con los sonidos agudos. Me provoca como una sincronía emocional, y es que cuando la música se vuelve introspectiva, como angustiosa, los visuales se tornan suaves y cuando hay tensión, aparecen líneas más marcadas y estructuras geométricas.

    * **Le Parody & Alba G. Corral**

      > Aquí la música tiene una base rítmica más marcada, con percusiones electrónicas y voz. Me parece que las visuales responden al ritmo de manera vibrante que se repiten y evolucionan. Van cambiando con los tonos de la música, vemos colores cálidos, contrastes fuertes y la conexión es más física, casi como si los visuales bailaran con la música.
      
2. Elementos generativos y por qué serian únicos.

Ambas performances muestran visuales que no son pregrabados ni estáticos, sino generativos, algunos elementos que resalto son:

   * Patrones que evolucionan: líneas, partículas y formas que se transforman en tiempo real.
     
  * Texturas cambiantes: superficies líquidas, diferentes estructuras, que van adaptandose a la música.
    
   * Aparición y desaparición de elementos: es como si los visuales tuvieran vida propia, emergen y se desvanecen según la intensidad sonora.
    
  > Estos elementos solo muestran como cada visualización puede ser única, incluso si se repitiera la misma música, porque la interacción en tiempo real, la interpretación del artista visual y las variaciones en la ejecución musical hacen que el resultado sea irrepetible.

3. Reflexión sobre "liveness"

La sensación de “liveness” es bastante envolvente, porque saber que los visuales se generan en tiempo real junto con la música crea una experiencia bastante única, espontánea y emocionalmente rica. No es solo una obra que se observa, sino una que se experimenta. Hay una tensión creativa entre lo sonoro y lo visual, como si ambos lenguajes se estuvieran improvisando mutuamente. Esto genera una conexión más íntima con el público porque la obra se visualiza dependiendo de cada usuario haciendola unica e irrepetible. 


### Actividad 02

1. pieza elegida

    [Next to you - JVKE](https://youtu.be/D4EWJZeol_0?si=VNhrWUvaGQApjVAK)

2. Concepto visual

    **Idea inicial**
   
   >  La canción habla del amor entre dos personas, y al escucharla y pensar en visuales, me imaginaba muchos movimientos sincronizados entre dos entes, que mediante los movimientos se mostrara ese deseo (quizas) de estar cerca de alguien, like truly in love (es mi imaginario artístico que siento sobre el amor real y puro al escuchar esta canción, en general, las canciones de este chico me llevan a pensar cosas lindas del amor).
   
   **Concepto evolucionado**
   
    > El concepto gira en torno a dos bolitas, que pueden ser esferas de luz, que representan a dos personas que buscan estar juntas (los entes que habia mencionado antes). Su movimiento es una danza romántica, sincronizada con la música, donde se atraen, se separan y finalmente se encuentran. La letra de la canción menciona unos ojos caleidoscopicos, entonces los visuales se inspiran en un mundo caleidoscópico, donde el espacio se transforma según la emoción musical:
   
   > * en los versos suaves, las bolitas flotan entre formas geométricas translúcidas que giran lentamente.
   > * en los estribillos o explosiones musicales, el entorno estalla en patrones caleidoscópicos, colores vibrantes y reflejos luminosos.
   > * en algunas secciones, las bolitas viajan por espacios tipo geometry dash, moviéndose por paredes, saltando obstáculos o cambiando de gravedad según el ritmo.

3. Inputs seleccionados

    > * **Amplitud (volumen general):** afecta la escala y brillo de las esferas del fondo. Cuando la intensidas sube, el amor se ve mas fuerte, porque la imagen vibra y se ilumina. 

    > * **Frecuencias graves (bajo y percusión):** afecta el movimiento rítmico del entorno (paredes, plataformas). Cada golpe de bajo impulsa el movimiento, como un latido que empuja a las bolitas a moverse.

    > * **Frecuencias medias:** afecta a los cambios de forma en el caleidoscopio, y permite que la geometría se expanda o contraiga con la melodía.                           

    > * **Frecuencias agudas (voces, sintetizadores altos):** afecta y crea chispas, partículas y destellos, que simbolizan la conexión emocional entre los personajes.

    > * **Tempo (BPM):** es la sincronización de animaciones o transiciones de cámara, que mantiene la cohesión entre música y visuales, reforzando la sensación de coreografía.


4. Algoritmos - técnicas

    >* **movimientos aleatorios suaves:** random walks con límites para mantener las cosas dentro del marco visual.
   > * **motion 101:** atracción entre las esferas.
   > * **añadir fuerzas de viento, gravitación, repulsión:** para formar los patrones caledoscopicos, para unir las esferas, y para separarlas, creando diferentes efectos en la narrativa de la historia.
   > *** ondas sinusoides:** para controlar el ritmo de los patrones caledoscopicos.
   > * **sistemas de particulas:** para que en fiferentes momentos en la canción hayan particulas que cambien con la música. quiero usar sistemas de sistemas, herencia y polimorfismo y repellers.
   > * **flow fields:** es para la base del movimiento caledoscopico.
   > * **Tipografia semantica:** para que hayan cambios, y atraer atención.
  
   **Otros algoritmos**
   > * **shaders reactivos al audio:** para los colores, brillos y distorsiones que respondan a las frecuencias en tiempo real.
   > * d**istorsiones radiales (caleidoscopicas):** generadas con simetria polar o fragmetación geometrica.
   > * **interpolación de color:** transiciones entre las paletas de colores para generar emociones. 

5. Bocetos y explicaciones

> este es el primer boceto, donde muestro mis dos propuestas principales en lo que se basaría toda la obra.

![Imagen de WhatsApp 2025-10-29 a las 12 53 08_4028c29d](https://github.com/user-attachments/assets/2aa0a553-3fed-4f64-8835-99c76fa1d470)

> A continuación, bocetos ya con forma, color, y como quisiera que se viera.

![Imagen de WhatsApp 2025-10-23 a las 19 17 12_b30a5f69](https://github.com/user-attachments/assets/aadd34bb-ca42-48d5-9e1d-276b19ee4ae8)

![Imagen de WhatsApp 2025-10-23 a las 19 17 12_15e99211](https://github.com/user-attachments/assets/140a10fe-d607-4c0c-ad93-791ad5de2e07)

![Imagen de WhatsApp 2025-10-23 a las 19 17 12_52b9bcff](https://github.com/user-attachments/assets/798e4ebf-532b-445a-a49a-87b6e3f1cfa5)

![Imagen de WhatsApp 2025-10-23 a las 19 17 12_86a84320](https://github.com/user-attachments/assets/d4dbcf99-7b56-46b5-b0e1-1c57089fe665)

### Actividad 03 - apply

1. codigo

`INDEX.HTML`

```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Next To You — base con caleidoscopio</title>

  <!-- p5 core + sound -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>

  <style>
    :root {
      --bg: #0b0b10;
      --fg: #e8eaf6;
      --muted: #9aa1b6;
      --glass: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.12);
      --accent: #9B5DE5;
    }
    html, body { margin:0; padding:0; background: var(--bg); color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    canvas { display:block; }

    #hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      background: var(--glass); border:1px solid var(--border); backdrop-filter: blur(8px);
      border-radius: 12px; padding: 10px 12px; font-size: 13px; line-height:1.35;
    }
    .btn, .label-file {
      appearance:none; border:1px solid var(--border);
      background: rgba(255,255,255,0.04); color:var(--fg);
      padding:6px 10px; border-radius:10px; cursor:pointer; font-size:13px;
    }
    .btn:hover, .label-file:hover { background: rgba(255,255,255,0.08); }
    .btn:active, .label-file:active { transform: translateY(1px); }
    #file { display:none; }
    #title { color:var(--muted); margin-left:6px; font-size:12px; max-width:36ch; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .dot { width:8px; height:8px; border-radius:50%; display:inline-block; margin-left:6px; background:#777; }
    .dot.playing { background: var(--accent); box-shadow: 0 0 0 2px rgba(155,93,229,0.25); }
  </style>
</head>
<body>
  <div id="hud">
    <label class="label-file" for="file">Agregar canción</label>
    <input id="file" type="file" accept="audio/*" />
    <button id="play" class="btn">Play</button>
    <button id="pause" class="btn">Pausa</button>
    <span id="title">Sin canción</span>
    <span id="statusDot" class="dot" title="estado"></span>
  </div>

  <script src="sketch.js"></script>
</body>
</html>
```

`SKETCH.JS`

```js
let song = null, amp = null, fft = null;
let isLoaded = false, isPlaying = false;
let fileInput, playBtn, pauseBtn, titleEl, statusDot;

const balls = [];
let danceCenter;      
let spinAngle = 0, spinSpeed = 0, spinDir = 1;
let emaLowShort = 0, emaLowLong = 0;
let emaMidShort = 0, emaMidLong = 0;
let burstUntil = 0;
let hueBase = 200, hueTarget = 200;
let hueSpan = 30, targetHueSpan = 30;
let segs = 12, segsTarget = 12;
let twist = 0.02, twistTarget = 0.02;
let rings = 22;
let peakLow, peakMid;
let orbitDir = 1;
let magnet = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  noStroke();
  colorMode(HSL, 360, 100, 100, 1);

  fileInput = select('#file'); playBtn = select('#play'); pauseBtn = select('#pause');
  titleEl = select('#title'); statusDot = select('#statusDot');
  fileInput.changed(handleFile); playBtn.mousePressed(handlePlay); pauseBtn.mousePressed(handlePause);

  amp = new p5.Amplitude(); amp.smooth(0.9);
  fft = new p5.FFT(0.8, 1024);
  peakLow = new p5.PeakDetect(20, 180, 0.12, 22);
  peakMid = new p5.PeakDetect(300, 3400, 0.1, 18);

  danceCenter = createVector(width * 0.5, height * 0.5);
  const c0 = color(210, 85, 55);
  balls.push(new DanceBall(createVector(width * 0.5 - 110, height * 0.5), 22, c0, random(PI)));
  balls.push(new DanceBall(createVector(width * 0.5 + 110, height * 0.5), 22, c0, random(PI)));
}

function draw() {
  const level = constrain(amp.getLevel(), 0, 0.8);
  const spectrum = fft.analyze();
  const centroid = fft.getCentroid();
  const energyLow  = fft.getEnergy(20, 150)   / 255;
  const energyMid  = fft.getEnergy(300, 3400) / 255;
  const energyHigh = fft.getEnergy(3400, 8000)/ 255;

  peakLow.update(fft); peakMid.update(fft);
  emaLowShort = lerp(emaLowShort, energyLow, 0.35);
  emaLowLong  = lerp(emaLowLong,  energyLow, 0.08);
  emaMidShort = lerp(emaMidShort, energyMid, 0.40);
  emaMidLong  = lerp(emaMidLong,  energyMid, 0.10);

  const tNow = millis();
  if ((peakLow.isDetected || (emaLowShort - emaLowLong) > 0.12) && level > 0.18) {
    burstUntil = tNow + 900;
  }
  const inBurst = tNow < burstUntil;

  if (peakMid.isDetected || (emaMidShort - emaMidLong) > 0.08) {
    hueTarget = (hueTarget + random(30, 80)) % 360;
    segsTarget = floor(constrain(map(emaMidShort, 0, 1, 10, 18) + random(-1, 1), 8, 20));
    twistTarget = 0.01 + emaMidShort * 0.08;
    setBallsHue(hueTarget);
  }

  targetHueSpan = (inBurst ? 360 : map(level, 0, 0.6, 40, 180)) * (0.8 + 0.4 * emaMidLong);
  hueSpan = lerp(hueSpan, targetHueSpan, inBurst ? 0.25 : 0.08);
  const hueDrift = (frameCount * 0.02) % 360;
  hueBase = lerpAngle(hueBase, (hueTarget * 0.7 + hueDrift * 0.3) % 360, 0.06);

  spinSpeed = lerp(spinSpeed, 0.00025 + emaLowLong * 0.0035, 0.06);
  spinAngle += spinSpeed * spinDir;
  segs = round(lerp(segs, segsTarget, 0.1));
  twist = lerp(twist, twistTarget, 0.12);

  drawKaleido({ level, centroid, energyLow, energyMid, energyHigh, spinAngle, hueBase, hueSpan, inBurst, segs, twist });


  const baseRadius = 60 + emaMidLong * 120;
  const orbitSpeed = (0.004 + emaLowLong * 0.03) * orbitDir;

  for (let i = 0; i < balls.length; i++) {
    const b = balls[i];
    b.advancePhase(orbitSpeed);

    const rMod = baseRadius * (1.0 + 0.35 * sin(b.phase * (1.2 + i * 0.15) + i));
    const angle = b.phase * (1.0 + i * 0.05);

    const desired = createVector(
      danceCenter.x + cos(angle) * rMod,
      danceCenter.y + sin(angle) * rMod
    );
    const steer = p5.Vector.sub(desired, b.pos).mult(0.06 + clamp01(energyHigh) * 0.05);
    b.applyForce(steer);

    if (magnet) applySpring(balls[0], balls[1], 36, 0.02);

    b.applyNoise(0.25);
    b.update(0.993);
    b.pulse(isPlaying ? level * 10 : 0.5);
    b.edges(40);

    const satBoost = map(constrain(centroid, 600, 4000), 600, 4000, 0.7, 1.1);
    b.setSatBright(clamp01(0.65 * satBoost + level * 0.8), clamp01(0.55 + level));
    b.draw();
  }

  statusDot.class(isPlaying ? 'dot playing' : 'dot');
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  // mantener el centro en el medio siempre
  danceCenter.set(width * 0.5, height * 0.5);
}

function mousePressed() { spinDir *= -1; }      // invertir giro del caleidoscopio
function keyPressed()   { if (key === ' ') magnet = true; }
function keyReleased()  { if (key === ' ') magnet = false; }

function handleFile() {
  const file = this.elt.files[0];
  if (!file) return;
  if (song) { try { song.stop(); song.dispose(); } catch(e){} song = null; }

  loadSound(URL.createObjectURL(file), snd => {
    song = snd; isLoaded = true; titleEl.html(file.name || 'Canción cargada');
    amp.setInput(song); fft.setInput(song);
  }, err => { console.warn('Error al cargar audio:', err); isLoaded = false; titleEl.html('Error al cargar'); });
}
function handlePlay() { if (isLoaded && song && !song.isPlaying()) { song.play(); isPlaying = true; } }
function handlePause(){ if (isLoaded && song &&  song.isPlaying()) { song.pause(); isPlaying = false; } }

function drawKaleido(A) {
  push();
  translate(width/2, height/2);
  rotate(A.spinAngle);

  const maxR = Math.hypot(width, height) * 0.75;
  background(230, 40, 6 + A.level * 12);

  for (let j = 0; j < rings; j++) {
    const r0 = (j / rings) * maxR;
    const r1 = ((j + 1) / rings) * maxR;

    for (let i = 0; i < A.segs; i++) {
      const a0b = (i / A.segs) * TWO_PI;
      const a1b = ((i + 1) / A.segs) * TWO_PI;
      const aTw = j * A.twist;
      const a0 = a0b + aTw;
      const a1 = a1b + aTw;

      const wob = 1 + 0.03 * sin(4 * a0 + millis() * 0.0015 + A.centroid * 0.0006);
      const rr1 = r1 * wob;

      const localHue = (A.hueBase + (A.hueSpan) * (i / A.segs + j / rings)) % 360;
      const sat = 60 + 35 * A.energyMid;
      const bri = (A.inBurst ? 34 : 24) + 55 * A.level;

      fill(localHue, sat, bri, 0.92);
      beginShape();
      vertex(r0 * cos(a0), r0 * sin(a0));
      vertex(r0 * cos(a1), r0 * sin(a1));
      vertex(rr1 * cos(a1), rr1 * sin(a1));
      vertex(rr1 * cos(a0), rr1 * sin(a0));
      endShape(CLOSE);

      stroke(localHue, 40, 85, 0.08 + 0.28 * A.energyHigh);
      strokeWeight(1);
      noFill();
      beginShape();
      vertex(r0 * cos(a0), r0 * sin(a0));
      vertex(r0 * cos(a1), r0 * sin(a1));
      vertex(rr1 * cos(a1), rr1 * sin(a1));
      vertex(rr1 * cos(a0), rr1 * sin(a0));
      endShape(CLOSE);
      noStroke();
    }
  }
  pop();
}

class DanceBall {
  constructor(pos, r, c, phase0=0) {
    this.pos = pos.copy();
    this.vel = p5.Vector.random2D().mult(random(0.5, 2));
    this.acc = createVector(0, 0);
    this.r = r; this.baseR = r; this.c = c;
    this.phase = phase0;
  }
  applyForce(f) { this.acc.add(f); }
  applyNoise(scale = 0.35) {
    const n = noise(this.pos.x * 0.001, this.pos.y * 0.001, frameCount * 0.004);
    const a = map(n, 0, 1, -PI, PI);
    this.applyForce(p5.Vector.fromAngle(a).mult(scale));
  }
  advancePhase(speed) { this.phase += speed; }
  update(damping = 0.99) { this.vel.add(this.acc); this.pos.add(this.vel); this.vel.mult(damping); this.acc.mult(0); }
  edges(pad = 0) {
    if (this.pos.x < pad + this.r && this.vel.x < 0) this.vel.x *= -0.85;
    if (this.pos.x > width - pad - this.r && this.vel.x > 0) this.vel.x *= -0.85;
    if (this.pos.y < pad + this.r && this.vel.y < 0) this.vel.y *= -0.85;
    if (this.pos.y > height - pad - this.r && this.vel.y > 0) this.vel.y *= -0.85;
    this.pos.x = constrain(this.pos.x, pad + this.r, width - pad - this.r);
    this.pos.y = constrain(this.pos.y, pad + this.r, height - pad - this.r);
  }
  pulse(amount = 0) {
    if (isPlaying) this.r = this.baseR * (1 + amount * 0.35);
    else this.r = this.baseR * (1 + 0.05 * (sin(millis() / 320) + 1) * 0.5);
  }
  setHue(h) {
    const s = saturation(this.c), l = lightness(this.c), a = alpha(this.c);
    this.c = color((h % 360 + 360) % 360, s, l, a);
  }
  setSatBright(s, l) {
    const h = hue(this.c), a = alpha(this.c);
    this.c = color(h, constrain(s*100,0,100), constrain(l*100,0,100), a);
  }
  draw() {
    push();
    translate(this.pos.x, this.pos.y);
    fill(hue(this.c), saturation(this.c), 60, 0.25);
    circle(0, 0, (this.r + 16) * 2);
    fill(this.c);
    circle(0, 0, this.r * 2);
    pop();
  }
}

function setBallsHue(h) { for (const b of balls) b.setHue(h); }
function applySpring(a, b, targetDist = 160, k = 0.003) {
  const delta = p5.Vector.sub(b.pos, a.pos);
  const d = max(delta.mag(), 0.001);
  const dir = delta.copy().div(d);
  const x = d - targetDist;
  const force = dir.mult(x * k);
  a.applyForce(force); b.applyForce(p5.Vector.mult(force, -1));
}

function clamp01(x){ return max(0, min(1, x)); }
function lerpAngle(a, b, t){ let d = (b - a + 540) % 360 - 180; return (a + d * t + 360) % 360; }
```

2. Enlace

    [Apply unidad 8](https://editor.p5js.org/saragaravitop/sketches/3K8bYTXxi)

3. Capturas

<img width="726" height="522" alt="image" src="https://github.com/user-attachments/assets/b56e2de1-2cab-4fe7-b820-4324e486dfb5" />


<img width="731" height="520" alt="image" src="https://github.com/user-attachments/assets/7deb7525-583d-424a-97ce-75de1196d8c7" />


Hola profeeee, mi autoevaluación es 5 porque según la rúbrica complete las 3 actividades, visualicé y analice las obras propuestas para tener inspiración y ver como otros artistas hicieron sus obras, luego pensé en un concepto a partir de una canción, pensé como quería que se viera visualmente y realice bocetos, pensé en los algoritmos e inputs que podría utilizar, finalmente, creo que realice un buen trabajo consciente, aunque no quedará como lo plantee en un principio, la idea base si fue cumplida exitosamente. 


